<html>
<head>
<title>A23_Sec24_22299426_jobayer-alam.txt</title>
</head>
<body bgcolor="white">
<hr/>
A23_Sec24_22299426_jobayer-alam.txt<p></p><pre>
TASK! 
def check_similar(building_1, building_2):
  current1= building_1
  current2= building_2
  def get_length(head):
        count = 0
        current = head
        while current:
            count += 1
            current = current.next
        return count

    # First compare lengths
  if get_length(building_1) != get_length(building_2):
      return 'Not Similar'
  

  while current1 and current2:
    if current1.elem!=current2.elem:
      return "Not similar"
    current1=current1.next
    current2=current2.next
    
  else:
<a name="2"></a><font color="#0000FF"><a href="match106-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_7.gif"/></a>

    return "similar"



TASK2

def sum_dist(head, arr):
    total = 0
    for dist in arr:
        current = head
        steps = 0
        while current and steps &lt; dist:
            current = current.next
            steps += 1
        if current:  
            total += current.elem
</font>        else:
            total += 0  
    return total
<a name="3"></a><font color="#00FFFF"><a href="match106-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_5.gif"/></a>

TASK3
def alternate_merge(head1, head2):
    curr1 = head1
    curr2 = head2

    while curr1 and curr2:
        next1 = curr1.next
        next2 = curr2.next

        curr1.next = curr2  # link node from list2 after curr1
</font>
        if next1 is None:
            break  # if list1 ends, stop linking

        curr2.next = next1  # link node from list1 after curr2

        # move forward
        curr1 = next1
        curr2 = next2

    return head1

task 4
def idGenerator(head1, head2, head3):
    
    prev = None
    current = head3
    while current:
        nxt = current.next
        current.next = prev
        prev = current
        current = nxt
    reversed_head3 = prev

    
    total = 0
    ptr1 = head1
    ptr2 = head2
    ptr3 = reversed_head3

    while ptr1 and ptr2 and ptr3:
        total += ptr1.elem + ptr2.elem + ptr3.elem
        ptr1 = ptr1.next
        ptr2 = ptr2.next
        ptr3 = ptr3.next

    dummy = None
    if total == 0:
        dummy = reversed_head3
        dummy.elem = 0
        dummy.next = None
    else:
        dummy = None
        while total &gt; 0:
            digit = total % 10
            node = reversed_head3
            reversed_head3 = reversed_head3.next
            node.elem = digit
            node.next = dummy
            dummy = node
            total = total // 10

   
    tail = dummy
    while tail.next:
        tail = tail.next
        tail.next = reversed_head3  
        return dummy 

ASSINGMENT 4
task 5
<a name="4"></a><font color="#FF00FF"><a href="match106-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_5.gif"/></a>

def sumOddAppend(head):
    if head is None or head.next == head:
        return  
    
    prev = head
    curr = head.next
    sum_odd = 0

    while curr != head:
</font>        if curr.elem %
            sum_odd += curr.elem
            prev.next = curr.next 
            curr = prev.next
        else:
            prev = curr
            curr = curr.next

    
    new_node = DNode(sum_odd)  
    prev.next = new_node
    new_node.next = head 
TAsk 6
<a name="0"></a><font color="#FF0000"><a href="match106-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_11.gif"/></a>

def pairJoin(dh1, dh2):
    curr1 = dh1.next  
    curr2 = dh2.next  
    prev = dh1        

    while curr1 and curr2:
      
        prev.next = curr1
        curr1.prev = prev
        prev = curr1
        curr1 = curr1.next

        
        prev.next = curr2
        curr2.prev = prev
        prev = curr2
        curr2 = curr2.next

    
    prev.next = dh1
    dh1.prev = prev
</font>  TASK 7
def rangeMove(dhead, start, end):
    current = dhead.next
<a name="1"></a><font color="#00FF00"><a href="match106-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_8.gif"/></a>

    while current != dhead:
        nxt = current.next  # Save next node, as we might move current
        if start &lt;= current.data &lt;= end:
            # Remove current node
            current.prev.next = current.next
            current.next.prev = current.prev

            # Insert before dummy head (i.e., at the end)
            last = dhead.prev
            last.next = current
            current.prev = last
            current.next = dhead
</font>            dhead.prev = current
        current = nxt



 </pre>
</body>
</html>
