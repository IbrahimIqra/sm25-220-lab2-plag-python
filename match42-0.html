<html>
<head>
<title>A23_Sec21_22201477_Md.-Ashraful-Gani.txt</title>
</head>
<body bgcolor="white">
<hr/>
A23_Sec21_22201477_Md.-Ashraful-Gani.txt<p></p><pre>
# Assignment Task 1: Building Block
<a name="4"></a><font color="#FF00FF"><a href="match42-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>

def check_similar(building_1, building_2):
    while building_1 and building_2:
        if building_1.elem != building_2.elem:
            return "Not Similar"
        building_1 = building_1.next
        building_2 = building_2.next
</font>    return "Similar" if not (building_1 or building_2) else "Not Similar"

# Assignment Task 2: Sum of Nodes
<a name="1"></a><font color="#00FF00"><a href="match42-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_11.gif"/></a>

def sum_dist(head, arr):
    total = 0
    for distance in arr:
        current = head
        count = 0
        while current and count &lt; distance:
            current = current.next
            count += 1
        if current:
            total += current.elem
    return total

# Assignment Task 3: Alternative Merge
def alternate_merge(head1, head2):
    if not head1:
        return head2
    if not head2:
        return head1
    merged_head = head1
</font><a name="2"></a><font color="#0000FF"><a href="match42-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_7.gif"/></a>

    while head1 and head2:
        temp1 = head1.next
        temp2 = head2.next
        head1.next = head2
        if temp1:
            head2.next = temp1
        head1 = temp1
        head2 = temp2
    return merged_head

# Assignment Task 4: ID Generator
def idGenerator(head1, head2, head3):
</font>    def reverse_list(head):
        prev = None
        current = head
        while current:
            next_node = current.next
            current.next = prev
            prev = current
            current = next_node
        return prev
    reversed_head1 = reverse_list(head1)
    first_part = []
    current = reversed_head1
    for _ in range(4):
        first_part.append(current.elem if current else 0)
        if current:
            current = current.next
    second_part = []
    current2, current3 = head2, head3
    for _ in range(4):
        val2 = current2.elem if current2 else 0
        val3 = current3.elem if current3 else 0
        second_part.append((val2 + val3) % 10)
        if current2:
            current2 = current2.next
        if current3:
            current3 = current3.next
    combined = first_part + second_part
    dummy = Node(0)
    current = dummy
    for num in combined[:8]:
        current.next = Node(num)
        current = current.next
    return dummy.next

# Assignment Task 5: Sum Odd Append
def sumOddAppend(head):
    if not head.next:
        return
<a name="3"></a><font color="#00FFFF"><a href="match42-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_5.gif"/></a>

    current = head.next
    prev = head
    total = 0
    while current != head:
        if current.elem % 2 != 0:
            total += current.elem
            prev.next = current.next
</font>        else:
            prev = prev.next
        current = prev.next
    if total != 0:
        new_node = Node(total)
        prev.next = new_node
        new_node.next = head

# Assignment Task 6: Pair Join
def pairJoin(dhead1, dhead2):
    curr1 = dhead1.next
    curr2 = dhead2.next
    while curr1 and curr2:
        next1 = curr1.next
        next2 = curr2.next
        curr1.next = curr2
        curr2.prev = curr1
        if next1:
            curr2.next = next1
            next1.prev = curr2
        curr1 = next1
        curr2 = next2
<a name="0"></a><font color="#FF0000"><a href="match42-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_16.gif"/></a>

    dhead2.next = None

# Assignment Task 7: Range Move
def rangeMove(dhead, start, end):
    if not dhead.next:
        return
    first = dhead.next
    last = dhead.prev
    prev = dhead
    curr = first
    while curr != dhead:
        next_node = curr.next
        if start &lt;= curr.elem &lt;= end:
            prev.next = next_node
            next_node.prev = prev
            last.next = curr
            curr.prev = last
            curr.next = dhead
            dhead.prev = curr
            last = curr
        else:
            prev = curr
</font>        curr = next_node</pre>
</body>
</html>
