<html>
<head>
<title>A23_Sec05_22201820_MD.-TAWFIQ-RAHMAN.txt</title>
</head>
<body bgcolor="white">
<hr/>
A23_Sec05_22201820_MD.-TAWFIQ-RAHMAN.txt<p></p><pre>
ï»¿ASSIGNMENT 2:

TASK 1:
def check_similar(building_1, building_2):
    current_1 = building_1
    current_2 = building_2


    # Traverse both lists simultaneously
<a name="2"></a><font color="#0000FF"><a href="match34-1.html#2" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_2_6.gif"/></a>

    while current_1 is not None and current_2 is not None:
        if current_1.elem != current_2.elem:
            return 'Not Similar'
        current_1 = current_1.next
        current_2 = current_2.next


    # After loop, both should be None if lengths are same
    if current_1 is None and current_2 is None:
        return 'Similar'
    else:
        return 'Not Similar'




TASK 2:
</font>
def sum_dist(head, arr):
    result = 0
    for index in arr:
        current = head
        count = 0
        # Traverse the list to reach the index-th node
        while current is not None and count &lt; index:
            current = current.next
            count += 1
        # If current is not None, we found the node
        if current is not None:
            result += current.elem
        else:
            result += 0  # index out of bounds, add 0
    return result




TASK 3:

def alternate_merge(head1, head2):
    if not head1:
        return head2
    if not head2:
        return head1


   
<a name="4"></a><font color="#FF00FF"><a href="match34-1.html#4" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_4_4.gif"/></a>

    curr1 = head1
    curr2 = head2




    while curr1 and curr2:
       
        next1 = curr1.next
        next2 = curr2.next


   
        curr1.next = curr2
</font>       
        if next1:
            curr2.next = next1
        else:
            curr2.next = None
       
       
        curr1 = next1
        curr2 = next2


    return head1


TASK 4:

def idGenerator(head1, head2, head3):


    reversed_digits = []
    current = head1
    while current:
        reversed_digits.insert(0, current.elem)  # Insert at the beginning to reverse the order
        current = current.next




    id_digits = reversed_digits[:4]  # First four digits are from reversed head1




    current2 = head2
    current3 = head3
<a name="5"></a><font color="#FF0000"><a href="match34-1.html#5" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_4.gif"/></a>

    for _ in range(4):
        sum_digits = current2.elem + current3.elem
        id_digits.append(sum_digits % 10)  # Add the result mod 10
        current2 = current2.next
        current3 = current3.next
</font><a name="3"></a><font color="#00FFFF"><a href="match34-1.html#3" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_3_5.gif"/></a>





    dummy_head = Node(None)
    current = dummy_head
    for digit in id_digits:
        current.next = Node(digit)
        current = current.next


    return dummy_head.next


Assignment 3
</font>
TASK 5:

def sumOddAppend(head):
    sum_odd = 0


    prev = head
    current = head.next


<a name="0"></a><font color="#FF0000"><a href="match34-1.html#0" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_0_15.gif"/></a>

    while current != head:
        if current.elem % 2 != 0:  # Odd value
            sum_odd += current.elem
            prev.next = current.next  # Remove current
            current = prev.next       # Move to next
        else:
            prev = current
            current = current.next


    # Insert one new node with sum of odd values at the end (before pointing to dummy head)
    new_node = Node(sum_odd)
    prev.next = new_node
    new_node.next = head  # Complete the circle


TASK 6:

def pairJoin(dhead1, dhead2):
    curr1 = dhead1.next
    curr2 = dhead2.next
    prev = dhead1


    while curr1 and curr2:
        # Link current node from list 1
        prev.next = curr1
        curr1.prev = prev
</font>        prev = curr1
        curr1 = curr1.next


        # Link current node from list 2
        prev.next = curr2
        curr2.prev = prev
        prev = curr2
        curr2 = curr2.next


    # Close the circular connection
    prev.next = dhead1
    dhead1.prev = prev


TASK 7:

def rangeMove(dhead1, start, end):
    if not dhead1 or dhead1.next == dhead1:
        return
    current = dhead1.next
    tail = dhead1.prev
<a name="1"></a><font color="#00FF00"><a href="match34-1.html#1" target="1"><img align="left" alt="other" border="0" src="http://moss.stanford.edu/bitmaps/tm_1_10.gif"/></a>

    stop = dhead1


    while current != stop:
        nxt = current.next


        if start &lt;= current.elem &lt;= end:


            current.prev.next = current.next
            current.next.prev = current.prev




            tail.next = current
            current.prev = tail
            current.next = dhead1
            dhead1.prev = current
</font>



            tail = current


        current = nxt</pre>
</body>
</html>
